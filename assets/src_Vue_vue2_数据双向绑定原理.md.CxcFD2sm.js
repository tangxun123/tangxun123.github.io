import{_ as o,c,o as d,ae as t}from"./chunks/framework.Dh1jimFm.js";const u=JSON.parse('{"title":"数据双向绑定原理","description":"","frontmatter":{},"headers":[],"relativePath":"src/Vue/vue2/数据双向绑定原理.md","filePath":"src/Vue/vue2/数据双向绑定原理.md","lastUpdated":null}'),r={name:"src/Vue/vue2/数据双向绑定原理.md"};function l(a,e,s,i,p,n){return d(),c("div",null,e[0]||(e[0]=[t('<h1 id="数据双向绑定原理" tabindex="-1">数据双向绑定原理 <a class="header-anchor" href="#数据双向绑定原理" aria-label="Permalink to &quot;数据双向绑定原理&quot;">​</a></h1><p><code>vue2</code> 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式， 通过 <code>Object.defineProperty()</code>来劫持各个属性的 <code>setter</code>，<code>getter</code>， 在数据变动时发布消息给订阅者，触发相应的监听回调。</p><ul><li>主要分为以下几个步骤：</li></ul><blockquote><ol><li>需要 <code>observe</code> 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 <code>setter</code> 和 <code>getter</code> 这样的话，给这个对象的某个值赋值，就会触发 <code>setter</code>，那么就能监听到了数据变化</li></ol></blockquote><blockquote><ol start="2"><li><code>compile</code> 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图， 并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li></ol></blockquote><blockquote><ol start="3"><li><p><code>Watcher</code> 订阅者是 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情是:</p><p>① 在自身实例化时往属性订阅器(dep)里面添加自己</p><p>② 自身必须有一个 <code>update()</code>方法</p><p>③ 待属性变动 <code>dep.notice()</code>通知时，能调用自身的 <code>update()</code>方法，并触发 <code>Compile</code> 中绑定的回调，则功成身退。</p></li></ol></blockquote><blockquote><ol start="4"><li><code>MVVM</code> 作为数据绑定的入口，整合 <code>Observer</code>、<code>Compile</code> 和 <code>Watcher</code> 三者， 通过 <code>Observer</code> 来监听自己的 <code>model</code> 数据变化，通过 <code>Compile</code> 来解析编译模板指令， 最终利用 <code>Watcher</code> 搭起 <code>Observer</code> 和 <code>Compile</code> 之间的通信桥梁， 达到 <strong>数据变化 -&gt; 视图更新</strong>；<strong>视图交互变化<code>(input)</code> -&gt; 数据 <code>model</code> 变更</strong>的双向绑定效果。</li></ol></blockquote>',7)]))}const m=o(r,[["render",l]]);export{u as __pageData,m as default};
