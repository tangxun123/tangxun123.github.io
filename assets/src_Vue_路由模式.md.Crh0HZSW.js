import{_ as a,c as e,o,aF as r}from"./chunks/framework.C249IrdD.js";const R=JSON.parse('{"title":"Vue 路由模式解答","description":"","frontmatter":{},"headers":[],"relativePath":"src/Vue/路由模式.md","filePath":"src/Vue/路由模式.md","lastUpdated":1742865501000}'),h={name:"src/Vue/路由模式.md"};function s(l,t,i,p,u,c){return o(),e("div",null,t[0]||(t[0]=[r('<h1 id="vue-路由模式解答" tabindex="-1">Vue 路由模式解答 <a class="header-anchor" href="#vue-路由模式解答" aria-label="Permalink to &quot;Vue 路由模式解答&quot;">​</a></h1><h2 id="vue-路由都有几种模式" tabindex="-1">vue 路由都有几种模式 <a class="header-anchor" href="#vue-路由都有几种模式" aria-label="Permalink to &quot;vue 路由都有几种模式&quot;">​</a></h2><p>Vue 路由有<strong>三种模式</strong> ，分别是：</p><ol><li><p><strong>hash 模式</strong>：在 URL 中使用 # 符号作为路由地址的前缀。在这种模式下，当 URL 发生改变时，页面不会重新加载，而是将 # 后面的部分作为参数，通过监听浏览器的 hashchange 事件来更新页面内容。这种模式不需要服务端支持。</p></li><li><p><strong>history 模式</strong>：在 URL 中不使用 # 符号，而是使用普通的 URL 地址。在这种模式下，当 URL 发生改变时，Vue Router 会尝试通过浏览器的 history.pushState 和 history.replaceState 方法修改浏览器的历史记录，从而在不刷新页面的情况下更新页面内容。需要注意的是，使用 history 模式需要服务器配置支持类似的请求路径，并返回相应的页面。</p></li><li><p><strong>abstract 模式</strong>：不依赖浏览器的 URL，而是通过程序控制路由跳转。在这种模式下，可以将路由映射到任意的数据源，比如本地存储、内存数据、服务器接口等。这种模式通常用于服务器渲染、单元测试等场景。</p></li></ol><p>可以通过在 Vue Router 的配置中设置 mode 属性来切换路由模式。默认情况下，Vue Router 使用 hash 模式。</p><h2 id="vue-路由有三种模式的区别" tabindex="-1">Vue 路由有三种模式的区别 <a class="header-anchor" href="#vue-路由有三种模式的区别" aria-label="Permalink to &quot;Vue 路由有三种模式的区别&quot;">​</a></h2><p>Vue 路由提供了三种模式：hash 模式、history 模式和 abstract 模式。它们的区别如下：</p><ol><li>hash 模式</li></ol><p>在 URL 中使用 # 符号作为路由地址的前缀，例如：<a href="http://localhost:8080/#/home%E3%80%82%E5%BD%93" target="_blank" rel="noreferrer">http://localhost:8080/#/home。当</a> URL 发生变化时，页面不会重新加载，而是通过监听浏览器的 hashchange 事件来更新页面内容。这种模式不需要服务端支持，可以轻松实现前端路由。在 hash 模式下，如果出现了 404 错误，会默认显示路由器中的路由。</p><ol start="2"><li>history 模式</li></ol><p>在 URL 中不使用 # 符号，而是使用普通的 URL 地址。在这种模式下，当 URL 发生改变时，页面不会重新加载，而是使用 HTML5 History API（pushState 和 replaceState 方法）在不刷新页面的情况下更新页面内容。这种模式需要服务端支持，因为在 history 模式下，浏览器发送的是真正的 HTTP 请求，服务器需要配置支持类似的请求路径，并返回相应的页面。如果服务器没有配置对应的路由规则，则会返回 404 错误。为了解决这个问题，可以使用 vue-router 提供的 history 模式的 Fallback 机制来处理路由的 404 错误。</p><ol start="3"><li>abstract 模式</li></ol><p>不依赖浏览器的 URL，而是通过程序控制路由跳转。可以将路由映射到任意的数据源，比如本地存储、内存数据、服务器接口等。这种模式通常用于服务器渲染、单元测试等场景。</p><p>在选择路由模式时，需要根据项目的实际情况来选择。如果项目需要兼容较老的浏览器，或者后端不支持 URL 重写，可以选择使用 hash 模式；如果需要更加优秀的用户体验，可以使用 history 模式；如果需要在一些特殊场景下使用路由，可以选择使用 abstract 模式。</p><h2 id="hash-模式和-history-模式的优缺点" tabindex="-1">hash 模式和 history 模式的优缺点 <a class="header-anchor" href="#hash-模式和-history-模式的优缺点" aria-label="Permalink to &quot;hash 模式和 history 模式的优缺点&quot;">​</a></h2><p>hash 模式和 history 模式都有各自的优缺点。</p><ol><li>hash 模式 优点：</li></ol><blockquote><p>兼容性好，支持在所有现代浏览器和较老的浏览器上使用。 不需要服务端支持，可以轻松实现前端路由。 URL 中的 hash 值可以用于保存页面状态，便于页面的前进、后退和分享等操作。 缺点：</p></blockquote><blockquote><p>URL 中带有 # 符号，不美观。 对于搜索引擎来说，URL 中的 # 后面的内容不被当作是 URL 的一部分，搜索引擎无法获取到其中的内容，对于 SEO 不友好。 如果出现 404 错误，默认情况下会显示路由器中的路由。</p></blockquote><ol start="2"><li>history 模式 优点：</li></ol><blockquote><p>URL 更加美观，不带有 # 符号。 对于搜索引擎来说，URL 中的内容完全被认为是 URL 的一部分，有利于 SEO。 可以通过服务器端配置实现前端路由，便于在服务端处理路由相关的逻辑。</p></blockquote><p>缺点：</p><blockquote><p>兼容性差，不支持在较老的浏览器上使用，需要使用 polyfill 进行兼容。 需要服务器端支持 URL 重写，否则会出现 404 错误。 URL 中不带有 # 符号，如果在页面刷新时，浏览器向服务器发送请求，可能会导致 404 错误。 需要根据项目的实际情况来选择使用哪种路由模式。如果项目需要兼容较老的浏览器，或者后端不支持 URL 重写，可以选择使用 hash 模式；如果需要更加优秀的用户体验，可以使用 history 模式。</p></blockquote><ol start="3"><li>abstract 模式 优缺点 abstract 模式是 Vue Router 提供的一种不依赖浏览器 URL 的路由模式，可以将路由映射到任意的数据源，比如本地存储、内存数据、服务器接口等。abstract 模式的优缺点如下：</li></ol><p>优点：</p><blockquote><p>不依赖浏览器 URL，可以在不同的数据源之间自由切换，灵活性高。 不需要服务端支持，可以轻松实现前端路由。 可以通过程序控制路由跳转，可以自定义路由的行为，比如跳转前进行数据加载等操作。</p></blockquote><p>缺点：</p><blockquote><p>不支持浏览器的前进和后退操作，需要自行实现历史记录和状态管理的逻辑。 对于搜索引擎来说，无法获取到 URL 中的内容，对于 SEO 不友好。 如果使用内存数据存储路由，当页面刷新时，路由信息会丢失。 需要根据项目的实际情况来选择使用哪种路由模式。abstract 模式通常用于服务器渲染、单元测试等场景。在这些场景下，不需要浏览器 URL 和前进后退功能，而是需要灵活控制路由的跳转行为。</p></blockquote><h2 id="三种路由模式的原理-详细一点" tabindex="-1">三种路由模式的原理，详细一点 <a class="header-anchor" href="#三种路由模式的原理-详细一点" aria-label="Permalink to &quot;三种路由模式的原理，详细一点&quot;">​</a></h2><p>Vue Router 支持三种路由模式：hash 模式、history 模式和 abstract 模式。它们的原理如下：</p><ol><li>hash 模式 hash 模式是 Vue Router 默认的路由模式，通过 URL 中的 # 符号来模拟一个完整的 URL，实际上 URL 中的 # 符号后面的内容被称为 hash（或哈希）值，用于指示浏览器在当前页面中的不同部分之间切换。例如，URL <a href="http://example.com/#/home" target="_blank" rel="noreferrer">http://example.com/#/home</a> 中的 /home 部分就是 hash 值，表示要访问的页面是 home。</li></ol><p>hash 模式的原理是，在页面加载时，Vue Router 会监听浏览器的 hashchange 事件，当 URL 中的 hash 值发生改变时，Vue Router 会解析新的 hash 值，并根据配置的路由规则来匹配对应的组件，最终将渲染结果显示在页面中。因为 hash 值的改变不会导致页面的重新加载，所以使用 hash 模式可以实现单页应用（SPA）的效果。</p><ol start="2"><li>history 模式 history 模式通过修改 URL 中的路径来实现路由，例如 <a href="http://example.com/home%EF%BC%8C%E5%85%B6%E4%B8%AD" target="_blank" rel="noreferrer">http://example.com/home，其中</a> /home 部分表示要访问的页面是 home。在使用 history 模式时，需要注意的是，服务器需要进行相应的配置，将所有的路径都指向同一个 HTML 文件，以避免在用户直接访问路径时出现 404 错误。</li></ol><p>history 模式的原理是，在页面加载时，Vue Router 会监听浏览器的 popstate 事件，当 URL 中的路径发生改变时，Vue Router 会解析新的路径，并根据配置的路由规则来匹配对应的组件，最终将渲染结果显示在页面中。因为 history 模式需要服务器的支持，所以它更适合用于传统的多页应用。</p><ol start="3"><li>abstract 模式 abstract 模式是一种不依赖浏览器 URL 的路由模式，可以将路由映射到任意的数据源，比如本地存储、内存数据、服务器接口等。在使用 abstract 模式时，需要自行实现路由信息的管理和状态的保存，包括前进和后退、路由跳转、路由钩子等功能。</li></ol><p>abstract 模式的原理是，在页面加载时，Vue Router 会通过程序调用来加载路由信息，然后根据路由信息来匹配对应的路由组件，最终将渲染结果显示在页面中。因为 abstract 模式不依赖于浏览器 URL，所以它更适合用于服务器渲染、单元测试等场景。</p>',36)]))}const b=a(h,[["render",s]]);export{R as __pageData,b as default};
