<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 面试题精选 | TX BLOG</title>
    <meta name="description" content="personal blog project">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.DalUE0zz.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.ChrSY29c.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.DcGFJ9yU.js">
    <link rel="modulepreload" href="/assets/chunks/framework.C249IrdD.js">
    <link rel="modulepreload" href="/assets/src_Vue_vue面试题.md.Dk7wdVoU.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><!--[--><div class="Layout" data-v-a9cbe35b><!--[--><!--]--><!--[--><span tabindex="-1" data-v-1841e730></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-1841e730>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9cbe35b data-v-76b549d2><div class="VPNavBar" data-v-76b549d2 data-v-00faf2bf><div class="wrapper" data-v-00faf2bf><div class="container" data-v-00faf2bf><div class="title" data-v-00faf2bf><div class="VPNavBarTitle has-sidebar" data-v-00faf2bf data-v-9466824f><a class="title" href="/" data-v-9466824f><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.jpg" alt data-v-c9217cd7><!--]--><span data-v-9466824f>TX BLOG</span><!--[--><!--]--></a></div></div><div class="content" data-v-00faf2bf><div class="content-body" data-v-00faf2bf><!--[--><!--]--><div class="VPNavBarSearch search" data-v-00faf2bf><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-00faf2bf data-v-a0bb3ad1><span id="main-nav-aria-label" class="visually-hidden" data-v-a0bb3ad1> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-a0bb3ad1 data-v-ff2f1e51><!--[--><span data-v-ff2f1e51>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/src/Git/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%A7%84%E8%8C%83.html" tabindex="0" data-v-a0bb3ad1 data-v-ff2f1e51><!--[--><span data-v-ff2f1e51>全部概览</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/src/Interview/interview.html" tabindex="0" data-v-a0bb3ad1 data-v-ff2f1e51><!--[--><span data-v-ff2f1e51>面试重点</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-00faf2bf data-v-1d0c1da1><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-1d0c1da1 data-v-77cecf79 data-v-94accba3><span class="check" data-v-94accba3><span class="icon" data-v-94accba3><!--[--><span class="vpi-sun sun" data-v-77cecf79></span><span class="vpi-moon moon" data-v-77cecf79></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-00faf2bf data-v-5da6cdfb data-v-09e0e621><!--[--><a class="VPSocialLink no-icon" href="https://github.com/" aria-label="github" target="_blank" rel="noopener" data-v-09e0e621 data-v-e332e63d><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-00faf2bf data-v-3d99c2e1 data-v-4ca743c3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-4ca743c3><span class="vpi-more-horizontal icon" data-v-4ca743c3></span></button><div class="menu" data-v-4ca743c3><div class="VPMenu" data-v-4ca743c3 data-v-4321c2e9><!----><!--[--><!--[--><!----><div class="group" data-v-3d99c2e1><div class="item appearance" data-v-3d99c2e1><p class="label" data-v-3d99c2e1>Appearance</p><div class="appearance-action" data-v-3d99c2e1><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3d99c2e1 data-v-77cecf79 data-v-94accba3><span class="check" data-v-94accba3><span class="icon" data-v-94accba3><!--[--><span class="vpi-sun sun" data-v-77cecf79></span><span class="vpi-moon moon" data-v-77cecf79></span><!--]--></span></span></button></div></div></div><div class="group" data-v-3d99c2e1><div class="item social-links" data-v-3d99c2e1><div class="VPSocialLinks social-links-list" data-v-3d99c2e1 data-v-09e0e621><!--[--><a class="VPSocialLink no-icon" href="https://github.com/" aria-label="github" target="_blank" rel="noopener" data-v-09e0e621 data-v-e332e63d><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--[--><!--[--><button class="full-width-button">DeepSeek</button><button class="full-width-button">宽屏布局</button><!--]--><!--]--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-00faf2bf data-v-6d374479><span class="container" data-v-6d374479><span class="top" data-v-6d374479></span><span class="middle" data-v-6d374479></span><span class="bottom" data-v-6d374479></span></span></button></div></div></div></div><div class="divider" data-v-00faf2bf><div class="divider-line" data-v-00faf2bf></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9cbe35b data-v-7f7162bc><div class="container" data-v-7f7162bc><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-7f7162bc><span class="vpi-align-left menu-icon" data-v-7f7162bc></span><span class="menu-text" data-v-7f7162bc>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-7f7162bc data-v-aa463266><button data-v-aa463266>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9cbe35b data-v-8869884c><div class="curtain" data-v-8869884c></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-8869884c><span class="visually-hidden" id="sidebar-aria-label" data-v-8869884c> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-e76462fe><section class="VPSidebarItem level-0" data-v-e76462fe data-v-f9911e3d><!----><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Git/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%A7%84%E8%8C%83.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Git</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-e76462fe><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-e76462fe data-v-f9911e3d><div class="item" role="button" tabindex="0" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><h2 class="text" data-v-f9911e3d>Vue</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-f9911e3d><span class="vpi-chevron-right caret-icon" data-v-f9911e3d></span></div></div><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/Object.defineProperty%E5%92%8CProxy.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Object.defineProperty和Proxy</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>路由模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>vue面试题</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible collapsed" data-v-f9911e3d data-v-f9911e3d><div class="item" role="button" tabindex="0" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><h3 class="text" data-v-f9911e3d>vue2</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-f9911e3d><span class="vpi-chevron-right caret-icon" data-v-f9911e3d></span></div></div><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue2/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>组件通信</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue2/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>数据双向绑定原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue2/computed%E5%92%8Cwatch.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>computed和watch</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue2/vuex%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>vuex刷新页面数据丢失</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue2/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>生成二维码</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible collapsed" data-v-f9911e3d data-v-f9911e3d><div class="item" role="button" tabindex="0" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><h3 class="text" data-v-f9911e3d>vue3</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-f9911e3d><span class="vpi-chevron-right caret-icon" data-v-f9911e3d></span></div></div><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue3/reactive.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Reactive</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue3/nextTick.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>nextTick</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue3/%E8%87%AA%E5%AE%9A%E4%B9%89Ref.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>自定义Ref</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Vue/vue3/vite%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>vite打包优化</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-e76462fe><section class="VPSidebarItem level-0 collapsible collapsed" data-v-e76462fe data-v-f9911e3d><div class="item" role="button" tabindex="0" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><h2 class="text" data-v-f9911e3d>React</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-f9911e3d><span class="vpi-chevron-right caret-icon" data-v-f9911e3d></span></div></div><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/React/Hook.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Hook</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/ReactNative/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%A9%BA%E7%99%BD.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>ReactNative 启动页空白</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/ReactNative/Android%E6%89%93%E5%8C%85APK.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Android打包APK</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/ReactNative/Navigation%E5%AF%BC%E8%88%AA%E5%99%A8.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Navigation导航器</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-e76462fe><section class="VPSidebarItem level-0 collapsible collapsed" data-v-e76462fe data-v-f9911e3d><div class="item" role="button" tabindex="0" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><h2 class="text" data-v-f9911e3d>每日一学</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-f9911e3d><span class="vpi-chevron-right caret-icon" data-v-f9911e3d></span></div></div><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/js/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>对象数组去重</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/js/%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>取数组的交集并集差集</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/js/Promise%20%E5%AE%9E%E7%8E%B0.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Promise 实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/js/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>前端图片优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/js/for%E5%BE%AA%E7%8E%AF%EF%BC%8C%E4%B8%AD%E6%96%AD%E5%A4%96%E5%B1%82%E5%BE%AA%E7%8E%AF.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>for循环，中断外层循环</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-e76462fe><section class="VPSidebarItem level-0 collapsible collapsed" data-v-e76462fe data-v-f9911e3d><div class="item" role="button" tabindex="0" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><h2 class="text" data-v-f9911e3d>学习随笔</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-f9911e3d><span class="vpi-chevron-right caret-icon" data-v-f9911e3d></span></div></div><div class="items" data-v-f9911e3d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/markDown.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>markDown</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/DOM/DOM.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>DOM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/npm.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>npm、nvm、nrm</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/Object.defineProperty.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Object.defineProperty</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/Array.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>判断是否是Array类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/axios%E5%B0%81%E8%A3%85.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>axios封装</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/Canvas/canvas.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>Canvas使用</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/babel.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>babel</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/dist.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>dist包如何在浏览器中直接打开</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/emotion.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>emotion表情</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/call%E3%80%81apply%E3%80%81bind.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>call、apply、bind的用法和区别</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>正则表达式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/%E7%BD%91%E7%AB%99%E4%B8%80%E9%94%AE%E7%BD%AE%E7%81%B0.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>网站一键置灰</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/%E5%AF%B9%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B8%B2%E6%9F%93.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>对流式数据的渲染</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>内存泄露和闭包、作用域</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f9911e3d data-v-f9911e3d><div class="item" data-v-f9911e3d><div class="indicator" data-v-f9911e3d></div><a class="VPLink link link" href="/src/studyMenus/sessionStorage%E3%80%81localStorage%E3%80%81cookie.html" data-v-f9911e3d><!--[--><p class="text" data-v-f9911e3d>sessionStorage、localStorage、cookie</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9cbe35b data-v-32755258><div class="VPDoc has-sidebar has-aside" data-v-32755258 data-v-3af9f359><!--[--><!--]--><div class="container" data-v-3af9f359><div class="aside" data-v-3af9f359><div class="aside-curtain" data-v-3af9f359></div><div class="aside-container" data-v-3af9f359><div class="aside-content" data-v-3af9f359><div class="VPDocAside" data-v-3af9f359 data-v-100497ab><!--[--><!--]--><!--[--><!--[--><!--[--><!--[--><div class="outline-title">页面导航</div><!--]--><!--]--><!--]--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-100497ab data-v-f48a36bb><div class="content" data-v-f48a36bb><div class="outline-marker" data-v-f48a36bb></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f48a36bb>On this page</div><ul class="VPDocOutlineItem root" data-v-f48a36bb data-v-0bbb2c95><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-100497ab></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3af9f359><div class="content-container" data-v-3af9f359><!--[--><!--]--><main class="main" data-v-3af9f359><div style="position:relative;" class="vp-doc _src_Vue_vue%E9%9D%A2%E8%AF%95%E9%A2%98" data-v-3af9f359><div><h1 id="vue-面试题精选" tabindex="-1">Vue 面试题精选 <a class="header-anchor" href="#vue-面试题精选" aria-label="Permalink to &quot;Vue 面试题精选&quot;">​</a></h1><h2 id="面试题大纲" tabindex="-1">面试题大纲 <a class="header-anchor" href="#面试题大纲" aria-label="Permalink to &quot;面试题大纲&quot;">​</a></h2><ul><li><ol><li>Vue2 和 Vue3 的区别？</li></ol></li><li><ol start="2"><li>Vue 的响应式原理是什么？</li></ol></li><li><ol start="3"><li>Vue 的生命周期是什么？</li></ol></li><li><ol start="4"><li>Vue 的组件之间如何通信？</li></ol></li><li><ol start="5"><li>Vuex 和 Vue 组件的区别是什么？</li></ol></li><li><ol start="6"><li>Vue 的路由是如何实现的？</li></ol></li><li><ol start="7"><li>Vue 的指令有哪些？</li></ol></li><li><ol start="8"><li>Vue 的过渡效果是如何实现的？</li></ol></li><li><ol start="9"><li>Vue 的单向数据流是什么？</li></ol></li><li><ol start="10"><li>Vue 的自定义指令是如何实现的？</li></ol></li><li><ol start="11"><li>Vue 的错误处理机制是什么？</li></ol></li><li><ol start="12"><li>Vue 的插件是如何实现的？</li></ol></li><li><ol start="13"><li>Vue 的高阶组件是什么？</li></ol></li><li><ol start="14"><li>Vue 的渲染函数是什么？</li></ol></li><li><ol start="15"><li>Vue 的 $nextTick 方法是干什么用的？</li></ol></li><li><ol start="16"><li>Vue 的 $set 和 $delete 方法是干什么用的？</li></ol></li><li><ol start="17"><li>Vue 的 keep-alive 是什么？</li></ol></li><li><ol start="18"><li>Vue 的计算属性和侦听器的区别是什么？</li></ol></li><li><ol start="19"><li>Vue 的 $emit 和 $on 方法是干什么用的？</li></ol></li><li><ol start="20"><li>Vue 的 $watch 和 $computed 方法有什么区别？</li></ol></li><li><ol start="21"><li>Vue 的 $attrs 和 $listeners 是什么？</li></ol></li><li><ol start="22"><li>Vue 的 Virtual DOM 是什么？</li></ol></li><li><ol start="23"><li>Vue 的模板语法有哪些？</li></ol></li><li><ol start="24"><li>Vue 的动态组件是如何实现的？</li></ol></li><li><ol start="25"><li>Vue 的路由守卫是什么？</li></ol></li><li><ol start="26"><li>Vue 的异步组件是如何实现的？</li></ol></li><li><ol start="27"><li>Vue 的父子组件之间的通信方式有哪些？</li></ol></li><li><ol start="28"><li>Vue 的路由懒加载是如何实现的？</li></ol></li><li><ol start="29"><li>Vue 的自定义过渡类名是如何实现的？</li></ol></li><li><ol start="30"><li>Vue 的插槽是什么？</li></ol></li><li><ol start="31"><li>Vue 的深度监听是如何实现的？</li></ol></li><li><ol start="32"><li>Vue 的组件递归是如何实现的？</li></ol></li><li><ol start="33"><li>Vue 的响应式设计思想是什么？</li></ol></li><li><ol start="34"><li>Vue 的路由懒加载和异步组件有什么区别？</li></ol></li><li><ol start="35"><li>Vue 的组件内部通信和全局通信有什么区别？</li></ol></li><li><ol start="36"><li>Vue 的组件内部状态和全局状态有什么区别？</li></ol></li><li><ol start="37"><li>Vue 的组件化和模块化的区别是什么？</li></ol></li><li><ol start="38"><li>Vue 的组件缓存和异步组件有什么区别？</li></ol></li><li><ol start="39"><li>Vue 的组件通信和状态管理有什么关系？</li></ol></li><li><ol start="40"><li>Vue 的组件内部状态管理和全局状态管理有什么区别？</li></ol></li><li><ol start="41"><li>Vue 的组件间通信有哪些常用的方式？</li></ol></li><li><ol start="42"><li>Vue computed watch 是不是异步?</li></ol></li></ul><h2 id="_1-vue2-和-vue3-的区别" tabindex="-1">1. Vue2 和 Vue3 的区别 <a class="header-anchor" href="#_1-vue2-和-vue3-的区别" aria-label="Permalink to &quot;1. Vue2 和 Vue3 的区别&quot;">​</a></h2><p>Vue 2 和 Vue 3 之间有许多不同之处，主要包括：</p><p>性能提升: Vue 3 通过重构其内部实现，带来了显著的性能提升。 Composition API: Vue 3 新增了 Composition API，这是一种全新的组件编写方式，可以更好地管理组件内部状态和逻辑。 Fragments: Vue 3 支持 Fragments，可以在渲染多个元素时不需要使用额外的包裹元素。 Teleport: Vue 3 新增了 Teleport，可以让你在不同位置渲染组件。 Suspense: Vue 3 支持 Suspense，可以在异步组件加载时显示 loading 状态。 代码结构变化： Vue 3 重构了其内部代码结构，使得组件的实现更加清晰明了。 其他新特性: Vue 3 还新增了一些其他新特性,如错误处理,异步组件,持久化状态,更好的 TypeScript 支持 总之, Vue 3 是一个更先进、更快捷的版本，带来了更好的开发体验和性能。</p><p>Portals 是 Vue 3 中的一个新特性，它允许组件将其内容呈现到任意 DOM 节点上，而不仅仅限于组件的根元素。当您想在组件根元素外显示内容时（例如在模态框或工具提示中），这在某些情况下非常有用。</p><p>以下是 Vue3 的例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;This is the component content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">portal</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#modal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;This content will be rendered in the #modal element&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">portal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export default {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MyComponent&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> This is the </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> where the component is used </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;modal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在上面的代码中，组件中的 <p>This content will be rendered in the #modal element</p> 将被呈现在页面的 <div id="modal"></div> 元素中。</p><h2 id="_2-vue-的响应式原理是什么" tabindex="-1">2. Vue 的响应式原理是什么？ <a class="header-anchor" href="#_2-vue-的响应式原理是什么" aria-label="Permalink to &quot;2. Vue 的响应式原理是什么？&quot;">​</a></h2><p>Vue 的响应式原理是通过 Object.defineProperty() 来实现的。</p><p>在 Vue 2 中，Vue 会在创建 Vue 实例时将数据对象的每个属性都使用 Object.defineProperty() 定义为 getter 和 setter。当数据发生改变时，会触发 setter 方法，在其中进行依赖收集和视图更新。</p><p>在 Vue 3 中,Vue 使用了 &quot;Proxy&quot; 代替了 Object.defineProperty() ,来更简单高效地实现响应式。Proxy 可以直接拦截对象属性的读写操作，而不需要通过定义 getter 和 setter。这样可以更简单地实现响应式，并且带来了性能提升。</p><p>可以通过 Object.defineProperty()和&quot;Proxy&quot; 分别写一个例子来说明 他们的区别</p><p>通过 Object.defineProperty() 实现响应式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John Doe&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> internalValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data[key];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, key, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Getting ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">internalValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> internalValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Setting ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      internalValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Jane Doe&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Setting name to Jane Doe</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data.name);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Getting name: Jane Doe</span></span></code></pre></div><p>通过 &quot;Proxy&quot; 实现响应式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John Doe&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Getting ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Setting ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxy.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Jane Doe&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Setting name to Jane Doe</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.name);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Getting name: Jane Doe</span></span></code></pre></div><p>我们可以发现，在使用 Object.defineProperty() 时，我们需要手动遍历对象的每个属性，并为每个属性分别定义 getter 和 setter。而在使用 Proxy 时，我们只需要定义一个通用的 handler 对象，就可以对整个对象进行拦截。</p><p>另外，在使用 Object.defineProperty() 实现响应式时，需要手动维护内部状态来存储属性值，这会增加代码的复杂度；而在使用 Proxy 实现响应式时，我们可以直接在 handler 中操作 target 对象，这样可以减少代码复杂度。</p><h2 id="_3-vue-的生命周期是什么" tabindex="-1">3. Vue 的生命周期是什么？ <a class="header-anchor" href="#_3-vue-的生命周期是什么" aria-label="Permalink to &quot;3. Vue 的生命周期是什么？&quot;">​</a></h2><p>Vue 的生命周期指的是组件在从创建到销毁的过程中会经历的各个阶段，Vue 在每个阶段都提供了对应的钩子函数，允许我们在特定时间点执行特定的操作。</p><p>Vue2 的生命周期阶段及钩子函数如下：</p><ul><li>beforeCreate: 组件实例刚被创建，但是还没有初始化。</li><li>created: 组件实例已经创建完成，并且已经初始化完成。</li><li>beforeMount: 组件实例即将被挂载到页面上。</li><li>mounted: 组件实例已经被挂载到页面上。</li><li>beforeUpdate: 组件实例即将更新。</li><li>updated: 组件实例已经更新完成。</li><li>beforeDestroy: 组件实例即将被销毁。</li><li>destroyed: 组件实例已经被销毁。 Vue3 的生命周期阶段与 Vue2 一样，只是增加了一个钩子函数：</li></ul><p>unmounted：组件实例从页面上被移除 总结：Vue3 的生命周期钩子函数与 Vue2 相同，只是增加了一个 unmounted 钩子函数。</p><h2 id="_4-vue-的组件之间如何通信" tabindex="-1">4. Vue 的组件之间如何通信？ <a class="header-anchor" href="#_4-vue-的组件之间如何通信" aria-label="Permalink to &quot;4. Vue 的组件之间如何通信？&quot;">​</a></h2><p>Vue2 和 Vue3 中组件之间的通信方式基本相同，都可以通过 props、$emit、$on、$off、$once 和 provide/inject 等方式来实现。</p><ul><li><ol><li>props: 父组件可以通过在组件标签上定义属性来向子组件传递数据，如 <!---->。子组件可以通过 props 选项来定义接收的属性，如 props: [&#39;myProp&#39;]，然后在组件的 template 中使用这些数据。</li></ol></li><li><ol start="2"><li>$emit: 子组件可以通过 $emit 方法触发事件，如 this.$emit(&#39;myEvent&#39;, someData)。父组件可以通过在组件标签上监听事件来接收这些数据，如 <!---->。</li></ol></li><li><ol start="3"><li>$on, $off, $once: 组件之间可以通过 $on 方法监听事件，通过 $off 方法取消监听，通过 $once 方法监听一次性事件。</li></ol></li><li><ol start="4"><li>provide/inject: Vue2.3 中新增的 provide 和 inject 主要用于祖先组件向后代组件传递数据。祖先组件可以在组件的选项中定义 provide 选项，并提供需要传递的数据，如 provide: { myData: this.myData }。后代组件可以在组件的选项中定义 inject 选项，来声明需要接收的数据，如 inject: [&#39;myData&#39;]。</li></ol></li><li><ol start="5"><li>EventBus Api: Vue3 中新增的 EventBus Api 可以在全局范围内监听和触发事件。可以通过 Vue.createEventBus() 创建一个全局的 EventBus 实例，然后在任意位置监听和触发事件。在组件中使用 EventBus 可以通过在组件的 mounted 钩子函数中绑定事件监听，在组件的 beforeDestroy 钩子函数中移除事件监听。</li></ol></li><li><ol start="6"><li>vuex : Vuex 是一个专门管理 Vue 应用状态的库，它提供了一个全局的 store 对象来存储数据，通过 actions 来更新数据。 区别: Vue 组件之间的通信主要是通过 props 和 $emit 来实现，而 Vuex 的作用是管理全局状态，并不是用来在组件之间传递数据的。</li></ol></li><li><ol start="7"><li>Vue3 的 Composition API : Vue3 中新增的 Composition API 主要是为了解决组件逻辑复杂，代码可维护性差的问题。Composition API 可以让我们通过函数式编程的思想来定义组件逻辑，并且可以将公共逻辑抽离出来，使组件之间可以共享。</li></ol></li></ul><h2 id="_5-vuex-和-vue-组件的区别是什么" tabindex="-1">5. Vuex 和 Vue 组件的区别是什么？ <a class="header-anchor" href="#_5-vuex-和-vue-组件的区别是什么" aria-label="Permalink to &quot;5. Vuex 和 Vue 组件的区别是什么？&quot;">​</a></h2><p>Vuex 和 Vue 组件都是 Vue 框架的重要部分，但是它们有着不同的功能和用途。</p><ul><li><p>Vuex 是一个状态管理库，主要用于管理应用中所有组件的共享状态。它提供了一个集中式的存储，让不同组件之间的状态变化可以被追踪和管理。</p></li><li><p>Vue 组件是 Vue 的基本构造块，用于构建用户界面。组件可以被复用，每个组件都有自己的状态和模板。组件之间可以通过 props 传递数据，通过 $emit 触发事件。</p></li></ul><p>总结：Vuex 主要用来管理应用中所有组件的共享状态，Vue 组件是 Vue 框架的基本构造块，用于构建用户界面。</p><h2 id="_6-vue-的路由是如何实现的" tabindex="-1">6. Vue 的路由是如何实现的？ <a class="header-anchor" href="#_6-vue-的路由是如何实现的" aria-label="Permalink to &quot;6. Vue 的路由是如何实现的？&quot;">​</a></h2><p>Vue 的路由是通过 vue-router 库来实现的。vue-router 是 Vue 官方提供的路由管理库，它可以将 URL 与组件进行映射，根据不同的 URL 展示不同的组件。</p><p>实现步骤如下：</p><ul><li>安装 vue-router 库</li><li>创建一个路由对象，并配置路由规则</li><li>将路由对象挂载到 Vue 根实例中</li><li>在组件中使用 <code>&lt;router-view&gt;</code> 标签来渲染路由对应的组件 例如：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VueRouter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(VueRouter);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Home},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: About}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  router,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>在组件中使用 <code>&lt;router-view&gt;</code> 标签来渲染路由对应的组件</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//App.vue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这样就完成了一个简单的路由配置，可以根据不同的 URL 展示不同的组件。</p><h3 id="原理呢" tabindex="-1">原理呢 <a class="header-anchor" href="#原理呢" aria-label="Permalink to &quot;原理呢&quot;">​</a></h3><p>Vue 的路由原理主要有两部分组成：</p><ul><li>HTML5 History API：这是一个浏览器自带的功能，可以在不刷新页面的情况下改变 URL，并且可以在返回和前进按钮中使用。</li><li>Vue-router 库：它是一个 Vue 插件，用来管理路由和与组件之间的映射关系。 在 Vue-router 中，使用了 Vue 的响应式系统来监听 URL 的变化，并在发生变化时动态渲染组件，这样就可以在不刷新页面的情况下实现路由的功能。</li></ul><p>当用户在浏览器中点击链接或者在应用中调用路由导航函数时，Vue-router 会监听到 URL 的变化，并将 URL 与配置的路由映射规则进行匹配。如果匹配成功，Vue-router 会在 <code>&lt;router-view&gt;</code> 标签中渲染对应的组件。这样就可以在不刷新页面的情况下实现路由的功能。</p><p>在 Vue3 和 Vue2 中路由实现原理是一样的，只不过 Vue3 中使用了更加高效的 Proxy 对象来实现响应式。</p><h2 id="_7-vue-的指令有哪些" tabindex="-1">7. Vue 的指令有哪些？ <a class="header-anchor" href="#_7-vue-的指令有哪些" aria-label="Permalink to &quot;7. Vue 的指令有哪些？&quot;">​</a></h2><p>Vue 的指令有以下几种：</p><ul><li>v-bind：用来绑定属性。</li><li>v-on：用来绑定事件监听器。</li><li>v-if：用来判断是否渲染元素。</li><li>v-for：用来遍历数组或者对象。</li><li>v-model：用来实现双向数据绑定。</li><li>v-text：用来更新元素的文本内容。</li><li>v-html：用来更新元素的 html 内容。</li><li>v-show：用来切换元素的显示和隐藏。</li><li>v-else：用来和 v-if 一起使用，表示当 v-if 条件不成立时的元素。</li><li>v-else-if：用来和 v-if 一起使用，表示当 v-if 条件不成立时可以接着判断其他条件。 Vue2 和 Vue3 中指令是相同的，没有新增或者删除指令。</li></ul><h2 id="_8-vue-的过渡效果是如何实现的" tabindex="-1">8. Vue 的过渡效果是如何实现的？ <a class="header-anchor" href="#_8-vue-的过渡效果是如何实现的" aria-label="Permalink to &quot;8. Vue 的过渡效果是如何实现的？&quot;">​</a></h2><p>Vue 的过渡效果是通过 Vue 的 <code>&lt;transition&gt;</code> 组件和 CSS 类实现的。</p><ul><li>在 Vue2 中，我们可以在 <code>&lt;transition&gt;</code> 组件中定义 enter/leave 的 CSS 类，来实现进入/离开时的动画效果。</li><li>在 Vue3 中，我们可以使用 transition 函数来实现过渡效果。 在 Vue3 中，我们可以使用 onBeforeEnter、onEnter、onAfterEnter 等 hooks 来实现过渡效果。</li></ul><p>Vue 2 和 Vue 3 的过渡效果实现方式有些不同。</p><p>Vue 2 中，过渡效果通过 CSS 类和 JavaScript 钩子函数来实现。使用者可以在组件中添加过渡类名，Vue 会自动在进入/离开过程中添加/删除这些类名。还可以在组件中添加 JavaScript 钩子函数，在进入/离开过程中触发。</p><p>Vue 3 中，过渡效果通过使用新的 <code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 组件实现。与 Vue 2 不同的是，Vue 3 中的过渡效果是基于 JavaScript 而不是 CSS 实现的。这意味着，Vue 3 中的过渡效果可以更灵活地控制，并且可以在 JavaScript 中添加额外的逻辑。</p><p>总结来说，Vue 2 中的过渡效果更依赖于 CSS，Vue 3 中的过渡效果更加灵活，可以在 JavaScript 中添加额外的逻辑。</p><h2 id="_9-vue-的单向数据流是什么" tabindex="-1">9. Vue 的单向数据流是什么？ <a class="header-anchor" href="#_9-vue-的单向数据流是什么" aria-label="Permalink to &quot;9. Vue 的单向数据流是什么？&quot;">​</a></h2><p>Vue 遵循单向数据流的原则，即数据的流动只能在父组件到子组件的单向流动，而不能在子组件到父组件的流动。这样做可以让组件之间的关系更加清晰易懂，并且在组件之间传递数据时不会出现意外情况。</p><p>单向数据流的实现主要通过 <code>props</code> 和 <code>$emit</code> 来实现。父组件可以通过 <code>props</code> 将数据传递给子组件，子组件可以通过 <code>$emit</code> 来触发事件给父组件。这样做可以让父组件对子组件的数据进行控制，并且可以在子组件触发事件时做出相应的反应。</p><h2 id="_10-vue-的自定义指令是如何实现的" tabindex="-1">10. Vue 的自定义指令是如何实现的？ <a class="header-anchor" href="#_10-vue-的自定义指令是如何实现的" aria-label="Permalink to &quot;10. Vue 的自定义指令是如何实现的？&quot;">​</a></h2><p>Vue 的自定义指令是通过 <code>Vue.directive()</code> 方法来实现的。可以在 Vue 实例或者 Vue 的全局配置中进行自定义指令的注册。</p><p>在 Vue2 中，自定义指令需要提供一个对象，其中包含 bind、update、unbind 三个钩子函数。</p><ul><li>bind：只调用一次，指令第一次绑定到元素时调用。</li><li>update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。</li><li>unbind：只调用一次，指令与元素解绑时调用。 在 Vue3 中，自定义指令需要提供一个函数，该函数接收一个 DirectiveArgs 对象。 DirectiveArgs 对象包含一组属性和方法，用于访问和控制元素和指令绑定的数据。</li></ul><p>在 Vue3 中，自定义指令是更为简单的，更加易用，更加灵活的。</p><p>通过自定义指令，可以实现更加复杂的操作，比如实现自定义事件、属性绑定等等。</p><h2 id="_11-vue-的错误处理机制是什么" tabindex="-1">11. Vue 的错误处理机制是什么？ <a class="header-anchor" href="#_11-vue-的错误处理机制是什么" aria-label="Permalink to &quot;11. Vue 的错误处理机制是什么？&quot;">​</a></h2><p>Vue 2 中，错误处理机制主要是通过配置 Vue 实例的 errorCaptured 钩子函数来实现的。这个钩子函数可以捕获组件内的所有错误，并且可以在组件树的任何层级上被调用。</p><p>Vue 3 中，错误处理机制和 Vue 2 相似，但是有所增强。首先 Vue 3 支持了 Error Handling API，可以在组件实例上配置 onError 钩子函数来处理错误。同时，Vue 3 也提供了 ErrorCaptured 声明式组件，可以在组件树上捕获错误，并且可以在任何层级上被调用</p><h2 id="_12-vue-的插件是如何实现的" tabindex="-1">12. Vue 的插件是如何实现的？ <a class="header-anchor" href="#_12-vue-的插件是如何实现的" aria-label="Permalink to &quot;12. Vue 的插件是如何实现的？&quot;">​</a></h2><p>Vue 插件是通过 <code>Vue.use()</code> 方法来实现的。Vue.use() 方法接受一个插件对象，该对象需要定义一个 install 方法，该方法会在 Vue.use() 被调用时执行。</p><p>在 Vue2 中，install 方法接收 Vue 构造函数作为参数，通过该参数可以访问 Vue.prototype 上的方法，进而实现插件的功能。</p><p>在 Vue3 中，install 方法接收 createApp 函数作为参数，通过该参数可以访问 app.config 上的方法，进而实现插件的功能。</p><p>举个例子，假设有一个自定义插件 myPlugin，它在 Vue2 中的实现可能长这样：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$myMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 自定义的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myPlugin);</span></span></code></pre></div><p>而在 Vue3 中的实现可能长这样：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    app.config.globalProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$myMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 自定义的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myPlugin);</span></span></code></pre></div><p>总结一下，Vue2 和 Vue3 中的插件实现方式类似，都是通过在 Vue 构造函数或 app.config 上添加自定义方法来实现插件功能。但是 Vue3 中，我们需要使用 createApp 创建应用然后使用 use 来注册插件，并且 Vue3 中，我们需要操作 app.config 来实现插件的功能。</p><h2 id="_13-vue-的高阶组件是什么" tabindex="-1">13. Vue 的高阶组件是什么？ <a class="header-anchor" href="#_13-vue-的高阶组件是什么" aria-label="Permalink to &quot;13. Vue 的高阶组件是什么？&quot;">​</a></h2><p>Vue 的高阶组件是一种可复用组件逻辑的方式。它是一个函数，接收一个组件作为参数，并返回一个新的组件。高阶组件可以在不修改原始组件的情况下，为组件提供额外的功能，如添加 props、监听器等。</p><p>在 Vue2 中，高阶组件可以通过 <code>Vue.extend()</code> 方法实现，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComponentWithExtraProps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    extraProp: String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(WrappedComponent, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        extraProp: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.extraProp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>在 Vue3 中，高阶组件可以通过 createComponent() 函数实现，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {createComponent} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComponentWithExtraProps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    extraProp: String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      createVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(WrappedComponent, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          extraProp: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.extraProp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这两种方式的实现方式基本一致，只是在 Vue3 中，高阶组件使用 <code>createComponent()</code> 来创建，并且需要通过 render 函数来渲染组件。</p><h2 id="_14-vue-的渲染函数是什么" tabindex="-1">14. Vue 的渲染函数是什么？ <a class="header-anchor" href="#_14-vue-的渲染函数是什么" aria-label="Permalink to &quot;14. Vue 的渲染函数是什么？&quot;">​</a></h2><p>Vue 的渲染函数是用来在 JavaScript 中声明组件的渲染逻辑的函数。在 Vue 2 中，渲染函数通过 template 选项或者 render 选项来定义。在 Vue 3 中，渲染函数是在 setup() 函数中返回的。渲染函数使用 JSX 语法，而不是模板语言，因此可以在 JavaScript 中操作组件的渲染。 渲染函数的优点是更加灵活，可以通过 JavaScript 来控制渲染逻辑，提升性能。 渲染函数是通过 JSX 产生的虚拟 DOM 来渲染组件，渲染函数和组件的生命周期钩子配合使用可以更好地控制组件的渲染。</p><h2 id="_15-vue-的-nexttick-方法是干什么用的" tabindex="-1">15. Vue 的 $nextTick 方法是干什么用的？ <a class="header-anchor" href="#_15-vue-的-nexttick-方法是干什么用的" aria-label="Permalink to &quot;15. Vue 的 $nextTick 方法是干什么用的？&quot;">​</a></h2><p>Vue 的 $nextTick 方法是用来在下一个 DOM 更新周期中使用的。当你在组件中更新了数据并希望立即更新视图，但是还没有到下一个 DOM 更新周期时，可以使用 $nextTick 方法。该方法接受一个回调函数作为参数，该回调函数在下一次 DOM 更新周期中被调用。在 Vue 2 和 Vue 3 中都支持 $nextTick 方法。</p><p>示例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$el.textContent); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这个示例中,我们改变了 message 的值，但是在下一个 DOM 更新周期才能看到最终的结果,我们可以用 <code>nextTick</code> 来保证在真正的 DOM 更新之后再执行代码。</p><p>nextTick 的原理</p><p>$nextTick 方法是 <code>Vue.js</code> 中的一个实例方法，它允许在下一次 DOM 更新循环结束之后执行延迟回调。这个方法的原理是在下一个 tick（即下一次 DOM 更新循环结束）中执行回调，主要用于在更新 DOM 之后操作 DOM。</p><p>实现原理是在 Vue 的更新队列中添加回调函数，在下一次 DOM 更新循环结束后调用这些回调函数。</p><p>在 vue2 和 vue3 中都有这个方法。</p><h2 id="_15-vue-的-set-和-delete-方法是干什么用的" tabindex="-1">15. Vue 的 $set 和 $delete 方法是干什么用的？ <a class="header-anchor" href="#_15-vue-的-set-和-delete-方法是干什么用的" aria-label="Permalink to &quot;15. Vue 的 $set 和 $delete 方法是干什么用的？&quot;">​</a></h2><h2 id="_16-vue-的-keep-alive-是什么" tabindex="-1">16. Vue 的 <code>keep-alive</code> 是什么？ <a class="header-anchor" href="#_16-vue-的-keep-alive-是什么" aria-label="Permalink to &quot;16. Vue 的 `keep-alive` 是什么？&quot;">​</a></h2><p>Vue 的 keep-alive 是一个 Vue 内置组件，它可以用来缓存组件实例，避免重复渲染和重新创建组件实例。当组件在进入/离开路由时，keep-alive 会将组件实例缓存在内存中，当组件再次进入该路由时，会直接使用缓存的组件实例，而不是重新创建。</p><p>在 Vue2 中，使用 <code>&lt;keep-alive&gt;</code> 标签包裹需要缓存的组件即可使用。在 Vue3 中，使用 vue.component 方法和 setup 函数来实现。</p><p>需要注意的是，使用 keep-alive 时，组件的 created、mounted 钩子函数只会在第一次创建时触发，而 activated 和 deactivated 钩子函数会在组件进入/离开缓存时触发。</p><h2 id="_17-vue-的计算属性和侦听器的区别是什么" tabindex="-1">17. Vue 的计算属性和侦听器的区别是什么？ <a class="header-anchor" href="#_17-vue-的计算属性和侦听器的区别是什么" aria-label="Permalink to &quot;17. Vue 的计算属性和侦听器的区别是什么？&quot;">​</a></h2><p>Vue 的计算属性和侦听器都可以用来响应数据变化，但是它们有一些显著的不同：</p><p>计算属性是基于它们的依赖进行缓存的。这意味着如果依赖没有发生变化，那么计算属性只会在第一次访问时计算一次。 侦听器不会缓存结果，并且在依赖发生变化时每次都会被调用。 总体而言，计算属性更适用于需要在模板中使用的复杂计算，而侦听器更适用于需要在数据变化时执行异步或开销较大的操作。</p><p>Vue2 和 Vue3 都支持计算属性和侦听器。在 vue2 中通过 computed 和 watch 来实现，在 vue3 中通过 computed 和 watchEffect 来实现。</p><p>计算属性是一种基于它们的依赖进行缓存的 getter 函数。</p><p>当依赖更改时，计算属性会重新求值。而侦听器是在数据变化时被调用的函数。 计算属性适用于需要在模板中展示计算结果的场景，而侦听器适用于需要在数据变化时执行异步或开销较大的操作的场景。</p><p><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#virtual-dom" target="_blank" rel="noreferrer">https://cn.vuejs.org/guide/extras/rendering-mechanism.html#virtual-dom</a></p><p>Vue 的 Virtual DOM 是一种 JavaScript 实现的虚拟 DOM，它可以在浏览器端帮助我们更高效地更新页面。 Vue 在渲染组件时会将组件的视图渲染成一棵 JavaScript 对象树，这棵树就是 Virtual DOM。 在每次组件状态变化时，Vue 会比较新旧 Virtual DOM 的差异并只更新需要更新的部分。 这样就可以避免不必要的 DOM 操作，从而提高性能。 Vue2 和 Vue3 使用的 Virtual DOM 实现方式是一致的。</p><h2 id="_23-vue-的模板语法有哪些" tabindex="-1">23. Vue 的模板语法有哪些？ <a class="header-anchor" href="#_23-vue-的模板语法有哪些" aria-label="Permalink to &quot;23. Vue 的模板语法有哪些？&quot;">​</a></h2><h2 id="_24-vue-的动态组件是如何实现的" tabindex="-1">24. Vue 的动态组件是如何实现的？ <a class="header-anchor" href="#_24-vue-的动态组件是如何实现的" aria-label="Permalink to &quot;24. Vue 的动态组件是如何实现的？&quot;">​</a></h2><h2 id="_25-vue-的路由守卫是什么" tabindex="-1">25. Vue 的路由守卫是什么？ <a class="header-anchor" href="#_25-vue-的路由守卫是什么" aria-label="Permalink to &quot;25. Vue 的路由守卫是什么？&quot;">​</a></h2><h2 id="_26-vue-的异步组件是如何实现的" tabindex="-1">26. Vue 的异步组件是如何实现的？ <a class="header-anchor" href="#_26-vue-的异步组件是如何实现的" aria-label="Permalink to &quot;26. Vue 的异步组件是如何实现的？&quot;">​</a></h2><h2 id="_27-vue-的父子组件之间的通信方式有哪些" tabindex="-1">27. Vue 的父子组件之间的通信方式有哪些？ <a class="header-anchor" href="#_27-vue-的父子组件之间的通信方式有哪些" aria-label="Permalink to &quot;27. Vue 的父子组件之间的通信方式有哪些？&quot;">​</a></h2><h2 id="_28-vue-的路由懒加载是如何实现的" tabindex="-1">28. Vue 的路由懒加载是如何实现的？ <a class="header-anchor" href="#_28-vue-的路由懒加载是如何实现的" aria-label="Permalink to &quot;28. Vue 的路由懒加载是如何实现的？&quot;">​</a></h2><h2 id="_29-vue-的自定义过渡类名是如何实现的" tabindex="-1">29. Vue 的自定义过渡类名是如何实现的？ <a class="header-anchor" href="#_29-vue-的自定义过渡类名是如何实现的" aria-label="Permalink to &quot;29. Vue 的自定义过渡类名是如何实现的？&quot;">​</a></h2><h2 id="_30-vue-的插槽是什么" tabindex="-1">30. Vue 的插槽是什么？ <a class="header-anchor" href="#_30-vue-的插槽是什么" aria-label="Permalink to &quot;30. Vue 的插槽是什么？&quot;">​</a></h2><h2 id="_31-vue-的深度监听是如何实现的" tabindex="-1">31. Vue 的深度监听是如何实现的？ <a class="header-anchor" href="#_31-vue-的深度监听是如何实现的" aria-label="Permalink to &quot;31. Vue 的深度监听是如何实现的？&quot;">​</a></h2><p>在 Vue 2 中，可以通过在 $watch 函数中设置 deep: true 来实现深度监听。Vue3 中没有提供 $watch 函数，但可以使用 computed 代替。</p><p>Vue 2 在源码中使用了 Object.defineProperty 和 Observer 类来实现对数据的深度监听，在调用 vm.$watch() 方法时，会在 Observer 类中遍历整个对象，使用 Object.defineProperty 为对象的每一个属性设置 getter 和 setter，以便在属性发生变化时触发回调函数。</p><p>Vue 3 中, 通过 Proxy 代替了 Object.defineProperty, 实现数据监听。在调用 setup()函数的时候，会调用内部的 reactive 函数来处理数据，并返回一个代理对象，在代理对象上的操作就会触发数据变化，进而触发视图更新。</p><h2 id="_32-vue-的组件递归是如何实现的" tabindex="-1">32. Vue 的组件递归是如何实现的？ <a class="header-anchor" href="#_32-vue-的组件递归是如何实现的" aria-label="Permalink to &quot;32. Vue 的组件递归是如何实现的？&quot;">​</a></h2><p>Vue 的组件递归是通过在组件中使用自己来实现的。在组件定义中加入 name 选项，然后在组件模板中使用该组件即可实现递归。可以使用 props 传递参数给递归组件来实现更多复杂的递归结构。</p><p>比如在组件中使用：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">my-component</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> :item=&quot;item&quot;&gt;&lt;/my-component&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  &lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;/template&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;script&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">export</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-component&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;div&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &lt;p&gt;{{ item.name }}&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &lt;my-component v-if=&quot;item.children&quot; v-for=&quot;child in item.children&quot; :key=&quot;child.id&quot; :item=&quot;child&quot;&gt;&lt;/my-component&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;/script&gt;</span></span></code></pre></div><p>在上述代码中，我们在 my-component 中使用了自己，并使用 v-for 指令来循环遍历子组件，实现了组件的递归。</p><p>注意在组件递归中，需要使用 key 来区分每个子组件，避免组件重复渲染。</p><h2 id="_33-vue-的响应式设计思想是什么" tabindex="-1">33. Vue 的响应式设计思想是什么？ <a class="header-anchor" href="#_33-vue-的响应式设计思想是什么" aria-label="Permalink to &quot;33. Vue 的响应式设计思想是什么？&quot;">​</a></h2><p>Vue 的响应式设计思想是在 Vue 实例创建时通过 Object.defineProperty() 方法劫持对象的 getter 和 setter 来实现。当绑定的数据变化时，Vue 会自动更新视图。这种机制称为响应式系统。</p><h2 id="_34-vue-的路由懒加载和异步组件有什么区别" tabindex="-1">34. Vue 的路由懒加载和异步组件有什么区别？ <a class="header-anchor" href="#_34-vue-的路由懒加载和异步组件有什么区别" aria-label="Permalink to &quot;34. Vue 的路由懒加载和异步组件有什么区别？&quot;">​</a></h2><p>Vue 的路由懒加载和异步组件主要的区别在于实现方式和使用场景上。</p><p>路由懒加载：是指在路由被访问时才加载对应的组件，而不是一次性全部加载。它是通过使用 Vue Router 的异步组件和 Webpack 的 code splitting 功能来实现的。 异步组件：是指将组件定义为一个工厂函数，在需要时才加载对应的组件。它主要用于在运行时动态加载组件。 总的来说，路由懒加载更适用于路由层面的代码分割，而异步组件则更适用于组件层面的动态加载。</p><h2 id="_35-vue-的组件内部通信和全局通信有什么区别" tabindex="-1">35. Vue 的组件内部通信和全局通信有什么区别？ <a class="header-anchor" href="#_35-vue-的组件内部通信和全局通信有什么区别" aria-label="Permalink to &quot;35. Vue 的组件内部通信和全局通信有什么区别？&quot;">​</a></h2><h2 id="_36-vue-的组件内部状态和全局状态有什么区别" tabindex="-1">36. Vue 的组件内部状态和全局状态有什么区别？ <a class="header-anchor" href="#_36-vue-的组件内部状态和全局状态有什么区别" aria-label="Permalink to &quot;36. Vue 的组件内部状态和全局状态有什么区别？&quot;">​</a></h2><h2 id="_37-vue-的组件化和模块化的区别是什么" tabindex="-1">37. Vue 的组件化和模块化的区别是什么？ <a class="header-anchor" href="#_37-vue-的组件化和模块化的区别是什么" aria-label="Permalink to &quot;37. Vue 的组件化和模块化的区别是什么？&quot;">​</a></h2><h2 id="_38-vue-的组件缓存和异步组件有什么区别" tabindex="-1">38. Vue 的组件缓存和异步组件有什么区别？ <a class="header-anchor" href="#_38-vue-的组件缓存和异步组件有什么区别" aria-label="Permalink to &quot;38. Vue 的组件缓存和异步组件有什么区别？&quot;">​</a></h2><h2 id="_39-vue-的组件通信和状态管理有什么关系" tabindex="-1">39. Vue 的组件通信和状态管理有什么关系？ <a class="header-anchor" href="#_39-vue-的组件通信和状态管理有什么关系" aria-label="Permalink to &quot;39. Vue 的组件通信和状态管理有什么关系？&quot;">​</a></h2><h2 id="_40-vue-的组件内部状态管理和全局状态管理有什么区别" tabindex="-1">40. Vue 的组件内部状态管理和全局状态管理有什么区别？ <a class="header-anchor" href="#_40-vue-的组件内部状态管理和全局状态管理有什么区别" aria-label="Permalink to &quot;40. Vue 的组件内部状态管理和全局状态管理有什么区别？&quot;">​</a></h2><h2 id="_41-vue-的组件间通信有哪些常用的方式" tabindex="-1">41. Vue 的组件间通信有哪些常用的方式？ <a class="header-anchor" href="#_41-vue-的组件间通信有哪些常用的方式" aria-label="Permalink to &quot;41. Vue 的组件间通信有哪些常用的方式？&quot;">​</a></h2><p>Vue 的组件间通信有多种常用的方式，如:</p><p>props 和<code>$emit</code>：父组件可以通过 props 传递数据给子组件，子组件可以通过$emit 触发事件给父组件 $parent和$children：父子组件可以通过$parent和$children直接访问对方 $refs：组件可以通过$refs来访问其它组件 vuex：组件可以通过 vuex 来进行全局状态管理 eventBus：组件可以通过 eventBus 来进行组件间通信 provide/inject：在 Vue 2.3.0+ 中新增的 provide/inject API，可以用来在父子组件间传递数据。 不同的场景使用不同的方式来进行组件间通信，需要根据项目需求进行选择。</p><h2 id="vue-computed-watch-是不是异步" tabindex="-1">Vue computed watch 是不是异步? <a class="header-anchor" href="#vue-computed-watch-是不是异步" aria-label="Permalink to &quot;Vue computed watch 是不是异步?&quot;">​</a></h2><p>在 Vue.js 中，computed 和 watch 是不同的东西，它们的行为也有所不同。</p><p>computed 计算属性是同步执行的，它依赖于响应式数据，只有当其依赖的数据发生变化时才会重新计算。computed 计算属性的值是缓存的，只有在其依赖的数据发生变化时才会重新计算，并且计算属性的值会被缓存起来，当多次读取计算属性时，会直接返回缓存的值，而不会重新计算。</p><p>watch 监听属性是异步执行的，它用于监听某个特定的数据的变化，一旦监听到数据变化就会触发回调函数，这个回调函数是异步执行的。当数据发生变化时，Vue.js 会将这个回调函数放到下一个事件循环中执行，以避免阻塞页面的渲染。</p><p>总的来说，computed 计算属性是同步执行的，而 watch 监听属性是异步执行的。这也是它们的区别之一。</p></div></div></main><footer class="VPDocFooter" data-v-3af9f359 data-v-ea4203a0><!--[--><!--]--><div class="edit-info" data-v-ea4203a0><!----><div class="last-updated" data-v-ea4203a0><p class="VPLastUpdated" data-v-ea4203a0 data-v-e3955208>最后更新于: <time datetime="2025-03-25T01:18:21.000Z" data-v-e3955208></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-ea4203a0><span class="visually-hidden" id="doc-footer-aria-label" data-v-ea4203a0>Pager</span><div class="pager" data-v-ea4203a0><a class="VPLink link pager-link prev" href="/src/Vue/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F.html" data-v-ea4203a0><!--[--><span class="desc" data-v-ea4203a0>上一页</span><span class="title" data-v-ea4203a0>路由模式</span><!--]--></a></div><div class="pager" data-v-ea4203a0><a class="VPLink link pager-link next" href="/src/Vue/vue2/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.html" data-v-ea4203a0><!--[--><span class="desc" data-v-ea4203a0>下一页</span><span class="title" data-v-ea4203a0>组件通信</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div><!--[--><div class="el-overlay" style="z-index:2022;display:none;"><!--[--><!--[--><div aria-modal="true" aria-label="DeepSeek" aria-describedby="el-id-6566-43" class="blog-drawer el-drawer rtl" style="width:70%;" role="dialog"><span class="el-drawer__sr-focus" tabindex="-1"></span><header class="el-drawer__header"><!--[--><span id="el-id-6566-42" role="heading" aria-level="2" class="el-drawer__title">DeepSeek</span><!--]--><button aria-label="Close this dialog" class="el-drawer__close-btn" type="button"><i class="el-icon el-drawer__close" style=""><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><path fill="currentColor" d="M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"></path></svg><!--]--></i></button></header><!--v-if--><!--v-if--></div><!--]--><!--]--></div><!--]--><!--]--></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DTVnXe0k\",\"src_canvas_canvas.md\":\"OBTo9rFH\",\"src_dom_dom.md\":\"C6Aceir9\",\"src_git_git工作流程及规范.md\":\"Dj4HmpP5\",\"src_interview_interview.md\":\"EGQEWt-p\",\"src_js_for循环，中断外层循环.md\":\"BYru7rwz\",\"src_js_promise 实现.md\":\"TtXDLQra\",\"src_js_前端图片优化.md\":\"__PgQ6AL\",\"src_js_取数组的交集并集差集.md\":\"CYg9uMVn\",\"src_js_对象数组去重.md\":\"DQpL5wWA\",\"src_react_hook.md\":\"BI2pI8f9\",\"src_reactnative_android打包apk.md\":\"Cg_6TnMR\",\"src_reactnative_navigation导航器.md\":\"DXfCRjBV\",\"src_reactnative_启动页空白.md\":\"DuIiEscc\",\"src_studymenus_array.md\":\"eJctI91D\",\"src_studymenus_axios封装.md\":\"CcZPFmA_\",\"src_studymenus_babel.md\":\"3I7ZTP3B\",\"src_studymenus_call、apply、bind.md\":\"CvyjmP_i\",\"src_studymenus_dist.md\":\"BRWHOL_4\",\"src_studymenus_emotion.md\":\"WgJgygnN\",\"src_studymenus_markdown.md\":\"l6nkHh_P\",\"src_studymenus_npm.md\":\"C1AhzWr1\",\"src_studymenus_object.defineproperty.md\":\"DtBNfb8g\",\"src_studymenus_sessionstorage、localstorage、cookie.md\":\"CrEtclFH\",\"src_studymenus_内存泄露和闭包、作用域.md\":\"CA0nc5Wa\",\"src_studymenus_对流式数据的渲染.md\":\"CRZ6RGR6\",\"src_studymenus_正则表达式.md\":\"EhjhbpW4\",\"src_studymenus_网站一键置灰.md\":\"BtrAvy8z\",\"src_vue_object.defineproperty和proxy.md\":\"ClJhQ2sE\",\"src_vue_vue2_computed和watch.md\":\"CAJWGVV-\",\"src_vue_vue2_vuex刷新页面数据丢失.md\":\"DakJLLUd\",\"src_vue_vue2_数据双向绑定原理.md\":\"Di3RaF5a\",\"src_vue_vue2_生成二维码.md\":\"DDz_sluI\",\"src_vue_vue2_组件传值.md\":\"BAI_YI0c\",\"src_vue_vue3_nexttick.md\":\"CJtD_KK1\",\"src_vue_vue3_reactive.md\":\"HAPROabk\",\"src_vue_vue3_vite打包优化.md\":\"DS4Jg3Tx\",\"src_vue_vue3_组件传值.md\":\"CY-SVU3N\",\"src_vue_vue3_自定义ref.md\":\"B6fbHUpv\",\"src_vue_vue面试题.md\":\"Dk7wdVoU\",\"src_vue_路由模式.md\":\"Crh0HZSW\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"TX BLOG\",\"description\":\"personal blog project\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.jpg\",\"search\":{\"provider\":\"local\"},\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"全部概览\",\"link\":\"/src/Git/Git工作流程及规范\"},{\"text\":\"面试重点\",\"link\":\"/src/Interview/interview\"}],\"sidebar\":[{\"text\":\"Git\",\"link\":\"/src/Git/Git工作流程及规范\"},{\"text\":\"Vue\",\"collapsed\":true,\"items\":[{\"text\":\"Object.defineProperty和Proxy\",\"link\":\"/src/Vue/Object.defineProperty和Proxy\"},{\"text\":\"路由模式\",\"link\":\"/src/Vue/路由模式\"},{\"text\":\"vue面试题\",\"link\":\"/src/Vue/vue面试题\"},{\"text\":\"vue2\",\"collapsed\":true,\"items\":[{\"text\":\"组件通信\",\"link\":\"/src/Vue/vue2/组件传值\"},{\"text\":\"数据双向绑定原理\",\"link\":\"/src/Vue/vue2/数据双向绑定原理\"},{\"text\":\"computed和watch\",\"link\":\"/src/Vue/vue2/computed和watch\"},{\"text\":\"vuex刷新页面数据丢失\",\"link\":\"/src/Vue/vue2/vuex刷新页面数据丢失\"},{\"text\":\"生成二维码\",\"link\":\"/src/Vue/vue2/生成二维码\"}]},{\"text\":\"vue3\",\"collapsed\":true,\"items\":[{\"text\":\"Reactive\",\"link\":\"/src/Vue/vue3/reactive\"},{\"text\":\"nextTick\",\"link\":\"/src/Vue/vue3/nextTick\"},{\"text\":\"自定义Ref\",\"link\":\"/src/Vue/vue3/自定义Ref\"},{\"text\":\"vite打包优化\",\"link\":\"/src/Vue/vue3/vite打包优化\"}]}]},{\"text\":\"React\",\"collapsed\":true,\"items\":[{\"text\":\"Hook\",\"link\":\"/src/React/Hook\"},{\"text\":\"ReactNative 启动页空白\",\"link\":\"/src/ReactNative/启动页空白\"},{\"text\":\"Android打包APK\",\"link\":\"/src/ReactNative/Android打包APK\"},{\"text\":\"Navigation导航器\",\"link\":\"/src/ReactNative/Navigation导航器\"}]},{\"text\":\"每日一学\",\"collapsed\":true,\"items\":[{\"text\":\"对象数组去重\",\"link\":\"/src/js/对象数组去重\"},{\"text\":\"取数组的交集并集差集\",\"link\":\"/src/js/取数组的交集并集差集\"},{\"text\":\"Promise 实现\",\"link\":\"/src/js/Promise 实现\"},{\"text\":\"前端图片优化\",\"link\":\"/src/js/前端图片优化\"},{\"text\":\"for循环，中断外层循环\",\"link\":\"/src/js/for循环，中断外层循环\"}]},{\"text\":\"学习随笔\",\"collapsed\":true,\"items\":[{\"text\":\"markDown\",\"link\":\"/src/studyMenus/markDown\"},{\"text\":\"DOM\",\"link\":\"/src/DOM/DOM\"},{\"text\":\"npm、nvm、nrm\",\"link\":\"/src/studyMenus/npm\"},{\"text\":\"Object.defineProperty\",\"link\":\"/src/studyMenus/Object.defineProperty\"},{\"text\":\"判断是否是Array类型\",\"link\":\"/src/studyMenus/Array\"},{\"text\":\"axios封装\",\"link\":\"/src/studyMenus/axios封装\"},{\"text\":\"Canvas使用\",\"link\":\"/src/Canvas/canvas\"},{\"text\":\"babel\",\"link\":\"/src/studyMenus/babel\"},{\"text\":\"dist包如何在浏览器中直接打开\",\"link\":\"/src/studyMenus/dist\"},{\"text\":\"emotion表情\",\"link\":\"/src/studyMenus/emotion\"},{\"text\":\"call、apply、bind的用法和区别\",\"link\":\"/src/studyMenus/call、apply、bind\"},{\"text\":\"正则表达式\",\"link\":\"/src/studyMenus/正则表达式\"},{\"text\":\"网站一键置灰\",\"link\":\"/src/studyMenus/网站一键置灰\"},{\"text\":\"对流式数据的渲染\",\"link\":\"/src/studyMenus/对流式数据的渲染\"},{\"text\":\"内存泄露和闭包、作用域\",\"link\":\"/src/studyMenus/内存泄露和闭包、作用域\"},{\"text\":\"sessionStorage、localStorage、cookie\",\"link\":\"/src/studyMenus/sessionStorage、localStorage、cookie\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/\"}],\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"short\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>